.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pegex::Grammar 3pm"
.TH Pegex::Grammar 3pm "2011-10-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Define a Pegex grammar (for the Foo syntax):
.PP
.Vb 2
\&    package Pegex::Grammar::Foo;
\&    use base \*(AqPegex::Grammar\*(Aq;
\&
\&    use constant text => q{
\&    foo: <bar> <baz>
\&    ... rest of Foo grammar ...
\&    };
\&    use constant receiver => \*(AqPegex::Receiver\*(Aq;
.Ve
.PP
then use it to parse some Foo:
.PP
.Vb 2
\&    use Pegex::Grammar::Foo;
\&    my $ast = Pegex::Grammar::Foo\->parse(\*(Aqmy/file.foo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pegex::Grammar is a base class for defining your own Pegex grammar classes. It
provides a single action method, `\fIparse()\fR`, that invokes a Pegex parser
(usually Pegex::Parser) for you, and then returns the kind of result that you
want it to. In other words, subclassing Pegex::Grammar is usually all you need
to do to create a parser/compiler for your language/syntax.
.PP
Pegex::Grammar classes are very simple. You just need to define a \f(CW\*(C`text\*(C'\fR
property that returns your Pegex grammar string, or (if you don't want to
incur the compilation of the grammar each time) a \f(CW\*(C`tree\*(C'\fR property which
returns a precompiled grammar.
.PP
You also need to define the receiver class or object that will produce a
result from your parse. 'Pegex::Receiver' is the easiest choice, as long as
you are satisfied which its results. Otherwise you can subclass it or define
something different.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
There are 4 properties of a Pegex::Grammar: \f(CW\*(C`tree\*(C'\fR, \f(CW\*(C`text\*(C'\fR, \f(CW\*(C`parser\*(C'\fR and
\&\f(CW\*(C`receiver\*(C'\fR.
.IP "tree" 4
.IX Item "tree"
This is the data structure containing the compiled grammar for your syntax. It
is usually produced by \f(CW\*(C`Pegex::Compiler\*(C'\fR. You can inline it in the \f(CW\*(C`tree\*(C'\fR
method, or else the \f(CW\*(C`tree_\*(C'\fR method will be called to produce it.
.Sp
The \f(CW\*(C`tree_\*(C'\fR method will call on Pegex::Compiler to compile the \f(CW\*(C`text\*(C'\fR
property by default. You can define your own \f(CW\*(C`tree_\*(C'\fR method to do override
this behavior.
.Sp
Often times you will want to generate your own Pegex::Grammar subclasses in an
automated fashion. The Pegex and TestML modules do this to be performant. This
also allows you to keep your grammar text in a separate file, and often in a
separate repository, so it can be shared by multiple programming language's
module implementations. See the src/ subdirectory in
<http://github.com/ingydotnet/pegex\-pm/>.
.IP "text" 4
.IX Item "text"
This is simply the text of your grammar, if you define this, you should
(probably) not define the \f(CW\*(C`tree\*(C'\fR property. This grammar text will be
automatically compiled when the \f(CW\*(C`tree\*(C'\fR is required.
.IP "parser" 4
.IX Item "parser"
This will default to \f(CW\*(C`Pegex::Parser\*(C'\fR and you should probably never need to
change that. It's the Parser class that will handle the work for the
\&\f(CW\*(C`parse()\*(C'\fR method. If you need to subclass the parser for some reason, you
would set the sublass here.
.IP "receiver" 4
.IX Item "receiver"
This will default to \f(CW\*(C`Pegex::Receiver\*(C'\fR. It is the class or object that will
handle all the callbacks from the parser, and do something with them. Usually
it will create a data structure representing the parsed input, but you can
have it do whatever you want. The default receiver creates a fairly messy data
structure with the result of your parse, but subclassing \f(CW\*(C`TestML::Receiver\*(C'\fR
is easy.
.Sp
You can also set this to a reference of your Grammar object, if you want to
specify all your grammar receiver callbacks inline. You can do that like this
(assuming a Moose compliant subclass):
.Sp
.Vb 4
\&    has receiver => (
\&        is => \*(Aqro\*(Aq,
\&        default => sub { shift },
\&    );
.Ve
.SH "METHODS"
.IX Header "METHODS"
There is only one public method:
.ie n .IP "parse($input [ , $start_rule ])" 4
.el .IP "parse($input [ , \f(CW$start_rule\fR ])" 4
.IX Item "parse($input [ , $start_rule ])"
The \f(CW\*(C`parse\*(C'\fR method applies the grammar against the text, and tells the
receiver object what is happening as it happens. If the parse fails, an error
is thrown. If it succeeds, then \f(CW\*(C`parse\*(C'\fR returns the data structure created by
the receiver object.
.Sp
This method is really just a handy proxy for \f(CW\*(C`Pegex::Parser::parse\*(C'\fR. It takes
the same input arguments and produces the same outputs.
.Sp
The first (required) argument is the input to be parsed. This can be a text
string, a file path, or a Pegex::Input object.
.Sp
The second (optional) argument is the starting rule name. By default, this is
the first rule specified in the grammar, or the rule named '\s-1TOP\s0' (if present).
