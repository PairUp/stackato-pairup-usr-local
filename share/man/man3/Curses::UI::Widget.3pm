.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Curses::UI::Widget 3pm"
.TH Curses::UI::Widget 3pm "2011-09-02" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Curses::UI::Widget \- The base class for all widgets
.SH "CLASS HIERARCHY"
.IX Header "CLASS HIERARCHY"
.Vb 1
\& Curses::UI::Widget \- base class
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This class is not used directly by somebody who is building an application
using Curses::UI. It's a base class that is expanded by the Curses::UI widgets.
See \s-1WIDGET\s0 \s-1STRUCTURE\s0 below for a basic widget framework.
.PP
.Vb 6
\&    use Curses::UI::Widget;
\&    my $widget = new Curses::UI::Widget(
\&        \-width  => 15,
\&        \-height => 5,
\&        \-border => 1,
\&    );
.Ve
.SH "STANDARD OPTIONS"
.IX Header "STANDARD OPTIONS"
The standard options for (most) widgets are the options that are enabled
by this class. So this class doesn't really have standard options.
.SH "WIDGET-SPECIFIC OPTIONS"
.IX Header "WIDGET-SPECIFIC OPTIONS"
.SS "\s-1GENERAL:\s0"
.IX Subsection "GENERAL:"
.IP "\(bu" 4
\&\fB\-parent\fR < \s-1OBJECTREF\s0 >
.Sp
This option specifies parent of the object. This parent is 
the object (Curses::UI, Window, Widget(descendant), etc.) 
in which the widget is drawn.
.IP "\(bu" 4
\&\fB\-intellidraw\fR < \s-1BOOLEAN\s0 >
.Sp
If \s-1BOOLEAN\s0 has a true value (which is the default), the
\&\fBintellidraw\fR method (see below) will be suported. This
option is mainly used in widget building.
.IP "\(bu" 4
\&\fB\-userdata\fR < \s-1SCALAR\s0 >
.Sp
This option specifies a user data that can be retrieved with
the \fBuserdata\fR() method.  It is useful to store application's
internal data that otherwise would not be accessible in callbacks.
.IP "\(bu" 4
\&\fB\-border\fR < \s-1BOOLEAN\s0 >
.Sp
Each widget can be drawn with or without a border. To enable
the border use a true value and to disable it use a 
false value for \s-1BOOLEAN\s0. The default is not to use a border.
.IP "\(bu" 4
\&\fB\-sbborder\fR < \s-1BOOLEAN\s0 >
.Sp
If no border is used, a square bracket border may be used.
This is a border which is constructed from '[' and ']' 
characters. This type of border is especially useful for 
single line widgets (like text entries and popup boxes).
A square bracket border can only be enabled if \-border 
is false. The default is not to use a square bracket border.
.SS "\s-1POSITIONING:\s0"
.IX Subsection "POSITIONING:"
.Vb 10
\& +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\& | parent                     ^                      |
\& |                            |                      |
\& |                            y                      |
\& |                            |                      |
\& |                            v                      |
\& |                            ^                      |
\& |                            |                      |
\& |                          padtop                   |
\& |                            |                      |
\& |                            v                      |
\& |                    +\- TITLE \-\-\-\-\-\-\-+              |
\& |                    | widget   ^    |              |
\& |                    |          |    |              |
\& |                    |          |    |              |
\& |<\-\-x\-\-><\-\-padleft\-\->|<\-\-\-\-width\-\-\-\->|<\-\-padright\-\->|
\& |                    |          |    |              |
\& |                    |          |    |              |
\& |                    |        height |              |
\& |                    |          v    |              |
\& |                    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+              |
\& |                               ^                   |
\& |                               |                   |
\& |                           padbottom               |
\& |                               |                   |
\& |                               v                   |
\& +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.IP "\(bu" 4
\&\fB\-x\fR < \s-1VALUE\s0 >
.Sp
The x\-position of the widget, relative to the parent. The default
is 0.
.IP "\(bu" 4
\&\fB\-y\fR < \s-1VALUE\s0 >
.Sp
The y\-position of the widget, relative to the parent. The default
is 0.
.IP "\(bu" 4
\&\fB\-width\fR < \s-1VALUE\s0 >
.Sp
The width of the widget. If the width is undefined or \-1,
the maximum available width will be used. By default the widget
will use the maximum available width.
.IP "\(bu" 4
\&\fB\-height\fR < \s-1VALUE\s0 >
.Sp
The height of the widget. If the height is undefined or \-1,
the maximum available height will be used. By default the widget
will use the maximum available height.
.SS "\s-1PADDING:\s0"
.IX Subsection "PADDING:"
.IP "\(bu" 4
\&\fB\-pad\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-padtop\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-padbottom\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-padleft\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-padright\fR < \s-1VALUE\s0 >
.Sp
With \-pad you can specify the default padding outside the widget
(the default value for \-pad is 0). Using one of the \-pad... options
that have a direction in them, you can override the default
padding.
.IP "\(bu" 4
\&\fB\-ipad\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-ipadtop\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-ipadbottom\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-ipadleft\fR < \s-1VALUE\s0 >
.IP "\(bu" 4
\&\fB\-ipadright\fR < \s-1VALUE\s0 >
.Sp
These are almost the same as the \-pad... options, except these options
specify the padding _inside_ the widget. Normally the available 
effective drawing area for a widget will be the complete area
if no border is used or else the area within the border.
.SS "\s-1TITLE:\s0"
.IX Subsection "TITLE:"
Remark:
.PP
A title is drawn in the border of a widget. So a title will only
be available if \-border is true.
.IP "\(bu" 4
\&\fB\-title\fR < \s-1TEXT\s0 >
.Sp
Set the title of the widget to \s-1TEXT\s0. If the text is longer then the 
available width, it will be clipped.
.IP "\(bu" 4
\&\fB\-titlereverse\fR < \s-1BOOLEAN\s0 >
.Sp
The title can be drawn in normal or in reverse type. If \-titlereverse
is true, the text will be drawn in reverse type. The default is to
use reverse type.
.IP "\(bu" 4
\&\fB\-titlefullwidth\fR < \s-1BOOLEAN\s0 >
.Sp
If \-titlereverse is true, the title can be stretched to fill the
complete width of the widget by giving \-titlefullwidth a true value.
By default this option is disabled.
.SS "\s-1SCROLLBARS:\s0"
.IX Subsection "SCROLLBARS:"
Remark:
.PP
Since the user of a Curses::UI program has no real control over
the so called \*(L"scrollbars\*(R", they aren't really scrollbars. A 
better name would be something like \*(L"document location indicators\*(R".
But since they look so much like scrollbars I decided I could get
away with this naming convention.
.IP "\(bu" 4
\&\fB\-vscrollbar\fR < \s-1VALUE\s0 >
.Sp
\&\s-1VALUE\s0 can be 'left', 'right', another true value or false.
.Sp
If \-vscrollbar has a true value, a vertical scrollbar will
be drawn by the widget. If this true value happens to be \*(L"left\*(R",
the scrollbar will be drawn on the left side of the widget. In 
all other cases it will be drawn on the right side. The default
is not to draw a vertical scrollbar.
.Sp
For widget programmers: To control the scrollbar, the widget
data \-vscrolllen (the total length of the content of the widget)
and \-vscrollpos (the current position in the document) should 
be set. If Curses::UI::Widget::draw is called, the scrollbar
will be drawn.
.IP "\(bu" 4
\&\fB\-hscrollbar\fR < \s-1VALUE\s0 >
.Sp
\&\s-1VALUE\s0 can be 'top', 'bottom', another true value or false.
.Sp
If \-hscrollbar has a true value, a horizontal scrollbar will
be drawn by the widget. If this true value happens to be \*(L"top\*(R",
the scrollbar will be drawn at the top of the widget. In 
all other cases it will be drawn at the bottom. The default
is not to draw a horizontal scrollbar.
.Sp
For widget programmers: To control the scrollbar, the widget
data \-hscrolllen (the maximum width of the content of the widget)
and \-hscrollpos (the current horizontal position in the document) 
should be set. If Curses::UI::Widget::draw is called, 
the scrollbar will be drawn.
.SS "\s-1EVENTS\s0"
.IX Subsection "EVENTS"
.IP "\(bu" 4
\&\fB\-onfocus\fR < \s-1CODEREF\s0 >
.Sp
This sets the onFocus event handler for the widget.
If the widget gets the focus, the code in \s-1CODEREF\s0 will 
be executed. It will get the widget reference as its 
argument.
.IP "\(bu" 4
\&\fB\-onblur\fR < \s-1CODEREF\s0 >
.Sp
This sets the onBlur event handler for the widget.
If the widget loses the focus, the code in \s-1CODEREF\s0 will 
be executed. It will get the widget reference as its 
argument.
.SH "METHODS"
.IX Header "METHODS"
.IP "\(bu" 4
\&\fBnew\fR ( \s-1OPTIONS\s0 )
.Sp
Create a new Curses::UI::Widget instance using the options in \s-1HASH\s0.
.IP "\(bu" 4
\&\fBlayout\fR ( )
.Sp
Layout the widget. Compute the size the widget needs and see
if it fits. Create the curses windows that are needed for
the widget (the border and the effective drawing area).
.IP "\(bu" 4
\&\fBdraw\fR ( \s-1BOOLEAN\s0 )
.Sp
Draw the Curses::UI::Widget. If \s-1BOOLEAN\s0 is true, the screen 
will not update after drawing. By default this argument is 
false, so the screen will update after drawing the widget.
.IP "\(bu" 4
\&\fBintellidraw\fR ( )
.Sp
If the widget is visible (it is not hidden and it is in the
window that is currently on top) and if intellidraw is not
disabled for it (\fB\-intellidraw\fR has a true value) it is drawn 
and the curses routine \fIdoupdate()\fR will be called to update 
the screen.
.Sp
This is useful if you change something in a widget and want 
it to update its state. If you simply call \fIdraw()\fR and 
\&\fIdoupdate()\fR yourself, then the widget will also be drawn if 
it is on a window that is currently not on top. This would 
result in the widget being drawn right through the contents 
of the window that is currently on top.
.IP "\(bu" 4
\&\fBfocus\fR ( )
.Sp
Give focus to the widget. In Curses::UI::Widget, this method
immediately returns, so the widget will not get focused. 
A derived class that needs focus, must override this method.
.IP "\(bu" 4
\&\fBfocusable\fR ( [\s-1BOOLEAN\s0] )
.Sp
If \s-1BOOLEAN\s0 is set to a true value the widget will be focusable,
false will make it unfocusable. If not argument is given,
it will return the current state.
.IP "\(bu" 4
\&\fBlose_focus\fR ( )
.Sp
This method makes the current widget lose it's focus.
It returns the current widget.
.IP "\(bu" 4
\&\fBmodalfocus\fR ( )
.Sp
Gives the widget a modal focus, i.e. no other widget can be active
till this widget is removed.
.IP "\(bu" 4
\&\fBtitle\fR ( \s-1TEXT\s0 )
.Sp
Change the title that is shown in the border of the widget
to \s-1TEXT\s0.
.IP "\(bu" 4
\&\fBwidth\fR ( )
.IP "\(bu" 4
\&\fBheight\fR ( )
.Sp
These methods return the total width and height of the widget.
This is the space that the widget itself uses plus the space that 
is used by the outside padding.
.IP "\(bu" 4
\&\fBborderwidth\fR ( )
.IP "\(bu" 4
\&\fBborderheight\fR ( )
.Sp
These methods return the width and the height of the border of the
widget.
.IP "\(bu" 4
\&\fBcanvaswidth\fR ( )
.IP "\(bu" 4
\&\fBcanvasheight\fR ( )
.Sp
These methods return the with and the height of the effective
drawing area of the widget. This is the area where the 
\&\fIdraw()\fR method of a widget may draw the contents of the widget
(\s-1BTW:\s0 the curses window that is associated to this drawing
area is \f(CW$this\fR\->{\-canvasscr}).
.IP "\(bu" 4
\&\fBwidth_by_windowscrwidth\fR ( \s-1NEEDWIDTH\s0, \s-1OPTIONS\s0 )
.IP "\(bu" 4
\&\fBheight_by_windowscrheight\fR ( \s-1NEEDHEIGHT\s0, \s-1OPTIONS\s0 )
.Sp
These methods are exported by this module. These can be used
in child classes to easily compute the total width/height the widget
needs in relation to the needed width/height of the effective drawing
area ($this\->{\-canvasscr}). The \s-1OPTIONS\s0 contains the options that
will be used to create the widget. So if we want a widget that
has a drawing area height of 1 and that has a border, the \-height
option can be computed using something like:
.Sp
.Vb 1
\&  my $height = height_by_windowscrheight(1, \-border => 1);
.Ve
.IP "\(bu" 4
\&\fBgeneric_focus\fR ( \s-1BLOCKTIME\s0, \s-1CTRLKEYS\s0, \s-1CURSOR\s0, \s-1PRECALLBACK\s0 )
.Sp
For most widgets the \fBgeneric_focus\fR method will be enough to 
handle focusing. This method will do the following:
.Sp
It starts a loop for reading keyboard input from the user. 
At the start of this loop the \s-1PRECALLBACK\s0 is called. This callback
can for example be used for layouting the widget. Then, the widget 
is drawn.
.Sp
Now a key is read or if the DO_KEY:<key> construction was used,
the <key> will be used as if it was read from the keyboard (you
can find more on this construction below). If the DO_KEY:<key>
construction was not used, a key is read using the \fBget_key\fR
method which is in Curses::UI::Common. 
The arguments \s-1BLOCKTIME\s0, \s-1CTRLKEYS\s0 and \s-1CURSOR\s0 are passed to 
\&\fBget_key\fR.
.Sp
Now the key is checked. If the value of the key is \-1, \fBget_key\fR
did not read a key at all. In that case, the program will go back
to the start of the loop.
.Sp
As soon as a key is read, this key will be handed to the
\&\fBprocess_bindings\fR method (see below). The returnvalue of this
method (called \s-1RETURN\s0 from now on) will be used to determine
what to do next. We have the following cases:
.Sp
* \fB\s-1RETURN\s0 matches DO_KEY:<key\fR>
.Sp
The <key> is extracted from \s-1RETURN\s0. The loop is restarted and
<key> will be used as if it was entered using the keyboard.
.Sp
* \fB\s-1RETURN\s0 is a \s-1CODE\s0 reference\fR
.Sp
\&\s-1RETURN\s0 will be returned to the caller of \fBgeneric_focus\fR. 
This will have the widget lose its focus. The caller then can 
execute the code.
.Sp
* \fB\s-1RETURN\s0 is a \s-1SCALAR\s0 value\fR
.Sp
\&\s-1RETURN\s0 will be returned to the caller of \fBgeneric_focus\fR. 
This will have the widget lose its focus.
.Sp
* \fBanything else\fR
.Sp
The widget will keep its focus. The loop will be restarted all 
over again. So, if you are writing a binding routine for a widget,
you can have the focus to stay at the widget by returning the 
widget instance itself. Example:
.Sp
.Vb 5
\&    sub myroutine() {
\&        my $this = shift;
\&        .... do your thing ....
\&        return $this;
\&    }
.Ve
.IP "\(bu" 4
\&\fBprocess_bindings\fR ( \s-1KEY\s0 )
.Sp
\&\s-1KEY\s0 \-> maps via binding to \-> \s-1ROUTINE\s0 \-> maps to \-> \s-1VALUE\s0
.Sp
This method will try to find out if there is a binding defined
for the \s-1KEY\s0. If no binding is found, the method will return
the widget object itself.
If a binding is found, the method will check if there is
an corresponding \s-1ROUTINE\s0. If the \s-1ROUTINE\s0 can be found it
will check if it's \s-1VALUE\s0 is a code reference. If it is, the
code will be executed and the returnvalue of this code will
be returned. Else the \s-1VALUE\s0 will directly be returned.
.IP "\(bu" 4
\&\fBclear_binding\fR ( \s-1ROUTINE\s0 )
.Sp
Clear all keybindings for routine \s-1ROUTINE\s0.
.IP "\(bu" 4
\&\fBset_routine\fR ( \s-1ROUTINE\s0, \s-1VALUE\s0 )
.Sp
Set the routine \s-1ROUTINE\s0 to the \s-1VALUE\s0. The \s-1VALUE\s0 may either be a 
scalar value or a code reference. If \fBprocess_bindings\fR (see above)
sees a scalar value, it will return this value. If it sees a
coderef, it will execute the code and return the returnvalue of
this code.
.IP "\(bu" 4
\&\fBset_binding\fR ( \s-1ROUTINE\s0, \s-1KEYLIST\s0 )
.Sp
Bind the keys in the list \s-1KEYLIST\s0 to the \s-1ROUTINE\s0. If you use an
empty string for a key, then this routine will become the default
routine (in case no other keybinding could be found). This 
is for example used in the TextEditor widget.
.IP "\(bu" 4
\&\fBset_event\fR ( \s-1EVENT\s0, [\s-1CODEREF\s0] )
.Sp
This routine will set the callback for event \s-1EVENT\s0 to
\&\s-1CODEREF\s0. If \s-1CODEREF\s0 is omitted or undefined, the event will 
be cleared.
.IP "\(bu" 4
\&\fBclear_event\fR ( \s-1EVENT\s0 )
.Sp
This will clear the callback for event \s-1EVENT\s0.
.IP "\(bu" 4
\&\fBrun_event\fR ( \s-1EVENT\s0 )
.Sp
This routine will check if a callback for the event \s-1EVENT\s0
is set and if is a code reference. If this is the case, 
it will run the code and return its return value.
.IP "\(bu" 4
\&\fBonFocus\fR ( \s-1CODEREF\s0 )
.Sp
This method can be used to set the \fB\-onfocus\fR event handler
(see above) after initialization of the widget.
.IP "\(bu" 4
\&\fBonBlur\fR ( \s-1CODEREF\s0 )
.Sp
This method can be used to set the \fB\-onblur\fR event handler
(see above) after initialization of the widget.
.IP "\(bu" 4
\&\fBparentwindow\fR ( )
.Sp
Returns this parent window for the widget or undef if
no parent window can be found (this should not happen).
.IP "\(bu" 4
\&\fBin_topwindow\fR ( )
.Sp
Returns true if the widget is in the window that is 
currently on top.
.IP "\(bu" 4
\&\fBuserdata\fR ( [ \s-1SCALAR\s0 ] )
.Sp
This method will return the user internal data stored in this widget.
If a \s-1SCALAR\s0 parameter is specified it will also set the current user 
data to it.
.IP "\(bu" 4
\&\fBbeep_on\fR ( )
.Sp
This sets the data member \f(CW$this\fR\->{\fB\-nobeep\fR} of the class instance
to a false value.
.IP "\(bu" 4
\&\fBbeep_off\fR ( )
.Sp
This sets the data member \f(CW$this\fR\->{\fB\-nobeep\fR} of the class instance
to a true value.
.IP "\(bu" 4
\&\fBdobeep\fR ( )
.Sp
This will call the curses \fIbeep()\fR routine, but only if \fB\-nobeep\fR
is false.
.SH "WIDGET STRUCTURE"
.IX Header "WIDGET STRUCTURE"
Here's a basic framework for creating a new widget. You do not have
to follow this framework. As long as your widget has the methods
\&\fInew()\fR, \fIlayout()\fR, \fIdraw()\fR and \fIfocus()\fR, it can be used in Curses::UI.
.PP
.Vb 1
\&    package Curses::UI::YourWidget
\&
\&    use Curses;
\&    use Curses::UI::Widget;  
\&    use Curses::UI::Common; # some common widget routines
\&
\&    use vars qw($VERSION @ISA);
\&    $VERSION = \*(Aq0.01\*(Aq;
\&    @ISA = qw(Curses::UI::Widget Curses::UI::Common);
\&
\&    # For a widget that can get focus, you should define
\&    # the routines that are used to control the widget.
\&    # Each routine has a name. This name is used in 
\&    # the definition of the bindings. 
\&    # The value can be a string or a subroutine reference. 
\&    # A string will make the widget return from focus.
\&    #
\&    my %routines = (
\&        \*(Aqreturn\*(Aq    => \*(AqLOSE_FOCUS\*(Aq,
\&        \*(Aqkey\-a\*(Aq     => \e&key_a,
\&        \*(Aqkey\-other\*(Aq => \e&other_key
\&    );
\&
\&    # Using the bindings, the routines can be binded to key\-
\&    # presses. If the keypress is an empty string, this means
\&    # that this is the default binding. If the key is not 
\&    # handled by any other binding, it\*(Aqs handled by this
\&    # default binding.
\&    #
\&    my %bindings = (
\&        KEY_DOWN()  => \*(Aqreturn\*(Aq,   # down arrow will make the 
\&                                   # widget lose it\*(Aqs focus
\&        \*(Aqa\*(Aq         => \*(Aqkey\-a\*(Aq,    # a\-key will trigger key_a()
\&        \*(Aq\*(Aq          => \*(Aqkey\-other\*(Aq # any other key will trigger other_key()
\&    );
\&
\&    # The creation of the widget. When doing it this way,
\&    # it\*(Aqs easy to make optional and forced arguments 
\&    # possible. A forced argument could for example be 
\&    # \-border => 1, which would mean that the widget
\&    # always has a border, which can\*(Aqt be disabled by the
\&    # programmer. The arguments can of course be used 
\&    # for storing the current state of the widget.
\&    #
\&    sub new () {
\&        my $class = shift;
\&        my %args = (
\&            \-optional_argument_1 => "default value 1",
\&            \-optional_argument_2 => "default value 2",
\&            ....etc....
\&            @_,
\&            \-forced_argument_1   => "forced value 1", 
\&            \-forced_argument_2   => "forced value 2", 
\&            ....etc....
\&            \-bindings            => {%bindings},
\&            \-routines            => {%routines},
\&        );
\&
\&        # Create the widget and do the layout of it.
\&        my $this = $class\->SUPER::new( %args );
\&    $this\->layout;
\&
\&    return $this;
\&    }
\&
\&    # Each widget should have a layout() routine. Here,
\&    # the widget itself and it\*(Aqs contents can be layouted.
\&    # In case of a very simple widget, this will only mean
\&    # that the Widget has to be layouted (in which case the
\&    # routine could be left out, since it\*(Aqs in the base
\&    # class already). In other cases you will have to add
\&    # your own layout code. This routine is very important,
\&    # since it will enable the resizeability of the widget!
\&    #
\&    sub layout () {
\&        my $this = shift;
\&
\&        $this\->SUPER::layout;
\&    return $this if $Curses::UI::screen_too_small;
\&
\&        ....your own layout stuff....
\&
\&        # If you decide that the widget does not fit on the
\&        # screen, then set $Curses::UI::screen_too_small
\&        # to a true value and return.    
\&        if ( ....the widget does not fit.... ) {
\&            $Curses::UI::screen_too_small++;
\&            return $this;
\&        }
\&
\&        return $this;
\&    }
\&
\&    # The widget is drawn by the draw() routine. The
\&    # $no_update part is used to disable screen flickering
\&    # if a lot of widgets have to be drawn at once (for
\&    # example on resizing or redrawing). The curses window
\&    # which you can use for drawing the widget\*(Aqs contents
\&    # is $this\->{\-canvasscr}.
\&    #
\&    sub draw(;$) {
\&        my $this = shift;
\&        my $no_doupdate = shift || 0;
\&        return $this if $this\->hidden;
\&        $this\->SUPER::draw(1);
\&
\&        ....your own draw stuff....
\&        $this\->{\-canvasscr}\->addstr(0, 0, "Fixed string");
\&        ....your own draw stuff....
\&
\&        $this\->{\-canvasscr}\->noutrefresh;
\&        doupdate() unless $no_doupdate;
\&    return $this;
\&    }
\&
\&    # Focus the widget. If you do not override this routine
\&    # from Curses::UI::Widget, the widget will not be 
\&    # focusable. Mostly you will use the generic_focus() method.
\&    #
\&    sub focus()
\&    {
\&        my $this = shift;
\&        $this\->show; # makes the widget visible if it was invisible
\&        return $this\->generic_focus(
\&            undef,             # delaytime, default = 2 (1/10 second).
\&            NO_CONTROLKEYS,    # disable controlkeys like CTRL+C. To enable
\&                               # them use CONTROLKEYS instead.
\&            CURSOR_INVISIBLE,  # do not show the cursor (if supported). To
\&                               # show the cursor use CURSOR_VISIBLE.
\&            \e&pre_key_routine, # optional callback routine to execute
\&                               # before a key is read. Mostly unused.
\&        );
\&    }  
\&
\&    ....your own widget handling routines....
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Curses::UI
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2001\-2002 Maurice Makaay. All rights reserved.
.PP
Maintained by Marcus Thiesen (marcus@cpan.thiesenweb.de)
.PP
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty. It may be used, redistributed and/or modified
under the same terms as perl itself.
