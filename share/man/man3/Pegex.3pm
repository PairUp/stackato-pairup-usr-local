.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pegex 3pm"
.TH Pegex 3pm "2011-11-05" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pegex;
\&    my $data = pegex($grammar)\->parse($input);
.Ve
.PP
or with regular expression sugar:
.PP
.Vb 3
\&    use Pegex::Regex;
\&    $input =~ qr{$grammar}x;
\&    my $data = \e%/;
.Ve
.PP
or more explicitly:
.PP
.Vb 6
\&    use Pegex::Grammar;
\&    use Pegex::Compiler;
\&    my $pegex_grammar = Pegex::Grammar\->new(
\&        tree => Pegex::Compiler\->compile($grammar)\->tree,
\&    );
\&    my $data = $pegex_grammar\->parse($input);
.Ve
.PP
or customized explicitly:
.PP
.Vb 3
\&    package MyGrammar;
\&    use Mo;
\&    extends \*(AqPegex::Grammar\*(Aq;
\&
\&    has text => default => sub {
\&        "your grammar definition text goes here";
\&    };
\&    has receiver => default => sub{"MyReceiver"};
\&
\&    package MyReceiver;
\&    use base \*(AqPegex::Receiver\*(Aq;
\&    got_some_rule { ... }
\&    got_other_rule { ... }
\&
\&    package main;
\&    use MyGrammar;
\&    my $grammar = MyGrammar\->new();
\&    $grammar\->parse($input);
\&    my $data = $receiver\->data;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pegex is a Acmeist parser framework. It allows you to easily create parsers
that will work equivalently in lots of programming langugages!
.PP
Pegex gets it name by combining Parsing Expression Grammars (\s-1PEG\s0), with
Regular Expessions (regex). That's actually what Pegex does.
.PP
\&\s-1PEG\s0 is the cool new way to elegantly specify recursive descent grammars. The
Perl 6 language is defined in terms of a self modifying \s-1PEG\s0 language called
\&\fBPerl 6 Rules\fR. Regular expressions are familar to programmers of most modern
programming languages. Pegex defines a simple \s-1PEG\s0 syntax, where all the
terminals are regular expressions. This means that Pegex can be quite fast and
powerful.
.PP
Pegex attempts to be the simplest way to define new (or old) Domain Specific
Languages (DSLs) that need to be used in several programming languages and
environments.
.SH "Pegex MODULE USAGE"
.IX Header "Pegex MODULE USAGE"
The \f(CW\*(C`Pegex.pm\*(C'\fR module itself is just a trivial way to use the Pegex
framework. It is only intended for the simplest of uses.
.PP
This module exports a single function, \f(CW\*(C`pegex\*(C'\fR, which takes a single value, a
Pegex grammar. The grammar value may be specified as a string, a file name, or
a file handle. The \f(CW\*(C`pegex\*(C'\fR function returns a Pegex::Grammar object, on
which you would typically call the \f(CW\*(C`parse()\*(C'\fR method, which (on success) will
return a data structure of the parsed data.
.SH "PEGEX OVERVIEW"
.IX Header "PEGEX OVERVIEW"
In the diagram below, there is a simple language called Foo. The diagram shows
how Pegex can take a text grammar defining Foo and generate a parser that can
parse Foo sources into data (abstract syntax trees).
.PP
.Vb 2
\&                            Parsing a language called "Foo"
\&                               with the Pegex toolset.    
\&
\&                              .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.      |    Pegex::Compiler    |
\&  |    Foo Language    |      |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|    Serialize
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\->| Pegex::Grammar::Pegex |\-\-\-\-\-\-\-\-\-.
\&  | Pegex grammar text |      | Pegex::Receiver       |         |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq      \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq         v
\&  ......................                  |                 .\-\-\-\-\-\-.
\&  |                    |                  | compile()       | YAML |
\&  |foo:: <verb> <noun> |                  v                 \*(Aq\-\-\-\-\-\-\*(Aq
\&  |verb: /Hello/       |       .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.       .\-\-\-\-\-\-.
\&  |noun: /world/       |       | Foo grammar tree   |       | JSON |
\&  |                    |       \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq       \*(Aq\-\-\-\-\-\-\*(Aq
\&  ......................                  |                 .\-\-\-\-\-\-.
\&                                          |                 | Perl |
\&                                          v                 \*(Aq\-\-\-\-\-\-\*(Aq
\&                               .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.      .\-\-\-\-\-\-\-\-.
\&                               | Pegex::Grammar::Foo |      | Python |
\&                               |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|      \*(Aq\-\-\-\-\-\-\-\-\*(Aq
\&                               | Pegex::Parser       |      .\-\-\-\-\-.
\&                               | Pegex::AST::Foo     |      | etc |
\&   .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.         \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq      \*(Aq\-\-\-\-\-\*(Aq
\&   |  Foo Language   |                    |
\&   |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->| parse()
\&   | Foo source text |                    v
\&   \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq        .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&   ...................        | Parsed Foo Data Tree |
\&   |Hello world      |        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&   ...................        ........................
\&                              |\- verb: Hello         |
\&                              |\- noun: world         |
\&                              ........................
.Ve
.SH "FYI"
.IX Header "FYI"
Pegex is self-hosting. This means that the Pegex grammar language syntax is
defined by a Pegex grammar! This is important because (just like any Pegex
based language) it makes it easier to port to new programming languages. You
can find the Pegex grammar for Pegex grammars here:
<http://github.com/ingydotnet/pegex\-pgx/>.
.PP
Pegex was originally inspired by Perl 6 Rules. It also takes ideas from Damian
Conway's Perl 5 module, Regexp::Grammars. Pegex tries to take the best
ideas from these great works, and make them work in as many languages as
possible. That's Acmeism.
.SH "SELF COMPILATION TRICKS"
.IX Header "SELF COMPILATION TRICKS"
You can have some fun using Pegex to compile itself. First get the Pegex grammar repo:
.PP
.Vb 2
\&    git clone git://github.com/ingydotnet/pegex\-pgx.git
\&    cd pegex\-pgx
.Ve
.PP
Then parse and dump the Pegex grammar with Pegex:
.PP
.Vb 1
\&    perl \-MXXX \-MPegex \-e \*(AqXXX pegex("pegex.pgx")\->parse("pegex.pgx")\*(Aq
.Ve
.PP
For a different view of the data tree, try:
.PP
.Vb 1
\&    perl \-MXXX \-MPegex \-e \*(AqXXX pegex("pegex.pgx", {wrap => 0})\->parse("pegex.pgx")\*(Aq
.Ve
.PP
Finally to emulate the Pegex compiler do this:
.PP
.Vb 1
\&    perl \-MXXX \-MPegex \-e \*(AqXXX pegex("pegex.pgx", {receiver => "Pegex::Pegex::AST"})\->parse("pegex.pgx")\*(Aq
.Ve
.PP
This specifies a \*(L"receiving\*(R" class that can shape the results into something
useful. Indeed, this is the exact guts of Pegex::Grammar::Pegex.
.SH "A REAL WORLD EXAMPLE"
.IX Header "A REAL WORLD EXAMPLE"
TestML is a new Acmeist unit test language. It is perfect for software that
needs to run equivalently in more than one language. In fact, Pegex itself is
tested with TestML!!
.PP
TestML has a language specification grammar:
http://www.testml.org/specification/language/
.PP
The Perl6 implementation of TestML uses this grammar in:
https://github.com/ingydotnet/testml\-pm6/blob/master/lib/TestML/Parser/Grammar.pm
.PP
All other implementations of TestML use this Pegex grammar:
https://github.com/ingydotnet/testml\-pgx/blob/master/testml.pgx
.PP
In Perl 5, Pegex::Compiler is used to compile the grammar into this simple
data structure (shown in \s-1YAML\s0):
https://github.com/ingydotnet/testml\-pgx/blob/master/testml.pgx.yaml
.PP
The grammar can also be precompiled to \s-1JSON:\s0
https://github.com/ingydotnet/testml\-pgx/blob/master/testml.pgx.json
.PP
Pegex::Compiler further compiles this into a Perl 5 only grammar tree, which
becomes this module:
https://github.com/ingydotnet/testml\-pm/blob/master/lib/TestML/Grammar.pm
.PP
TestML::Parser::Grammar is a subclass of Pegex::Grammar. It can be used to
parse TestML files. TestML::Parser calls the \f(CW\*(C`parse()\*(C'\fR method of the grammar
with a TestML::AST object that receives callbacks when various rules match,
and uses the information to build a TestML::Document object.
.PP
Thus TestML is an Acmeist language written in Pegex. It can be easily ported
to every language where Pegex exists. In fact, it must be ported to those
languages in order to test the new Pegex implementation!
